import { RefObject } from 'react';

interface DrawingParams {
  ctx: CanvasRenderingContext2D;
  width: number;
  height: number;
  temp: number;
  time: number;
  isRunning: boolean;
  params: { T0: number, Tambient: number, k: number };
  imagesLoaded: boolean;
  isLightMode: boolean;
  cpuImageRef: RefObject<HTMLImageElement | null>;
  heatsinkImageRef: RefObject<HTMLImageElement | null>;
  fancoolerImageRef: RefObject<HTMLImageElement | null>;
  liquidImageRef: RefObject<HTMLImageElement | null>;
}

export const calculateTemp = (t: number, params: { T0: number, Tambient: number, k: number }): number => {
  const { T0, Tambient, k } = params;
  return Tambient + (T0 - Tambient) * Math.exp(-k * t);
};

export const drawScene = (params: DrawingParams) => {
  const { ctx, width, height, temp, time, isRunning, params: simParams, imagesLoaded, isLightMode, cpuImageRef, heatsinkImageRef, fancoolerImageRef, liquidImageRef } = params;
  const { T0, Tambient, k } = simParams;

  // Background gradient - berdasarkan mode terang/gelap
  if (isLightMode) {
    ctx.fillStyle = '#f0f9ff';
    ctx.fillRect(0, 0, width, height);
  } else {
    const bgGrad = ctx.createLinearGradient(0, 0, 0, height);
    bgGrad.addColorStop(0, '#050814');
    bgGrad.addColorStop(1, '#0f1729');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, width, height);
  }

  // Main 3D system
  drawMainSystem({ ctx, width, height, temp, time, isRunning, params: simParams, isLightMode, cpuImageRef, heatsinkImageRef, fancoolerImageRef, liquidImageRef });

  // Graph
  drawTemperatureGraph({ ctx, width, height, temp, time, params: simParams, isLightMode });
};

const drawMainSystem = (params: Omit<DrawingParams, 'imagesLoaded'>) => {
  const { ctx, width, height, temp, time, isRunning, params: simParams, isLightMode, cpuImageRef, heatsinkImageRef, fancoolerImageRef, liquidImageRef } = params;
  const { T0, Tambient, k } = simParams;
  
  const centerX = width / 2;
  const centerY = 400;

  // ============ AMBIENT AIR (TOP) ============
  drawAmbientAir(ctx, centerX, 50, Tambient, isLightMode);

  // ============ FAN ============
  const fanY = centerY - 130;
  drawFan(ctx, centerX, fanY, isRunning, time, isLightMode);

  // Airflow arrows
  if (isRunning) {
    const offset = (time * 50) % 60;
    for (let i = 0; i < 4; i++) {
      const ay = fanY + 70 - i * 60 + offset;
      if (ay > 20 && ay < fanY + 40) {
        drawAirflowArrow(ctx, centerX + 100, ay - 40, centerX + 100, ay, isLightMode);
      }
    }
    for (let i = 0; i < 4; i++) {
      const ay = fanY + 90 - i * 60 - offset;
      if (ay > 20 && ay < fanY + 20) {
        drawHotAirArrow(ctx, centerX - 100, ay + 40, centerX - 100, ay, isLightMode);
      }
    }
  }

  // ============ HEATSINK ============
  const hsY = centerY - 40;
  drawHeatsink(ctx, centerX, hsY, k, heatsinkImageRef, fancoolerImageRef, liquidImageRef, isLightMode);

  // Heat transfer arrows from CPU to heatsink
  const tempRatio = (temp - Tambient) / (T0 - Tambient);
  if (tempRatio > 0.05) {
    const heatOffset = (time * 25) % 30;
    for (let i = 0; i < 4; i++) {
      const hy = centerY + 50 - i * 35 + heatOffset;
      if (hy > hsY + 60 && hy < centerY + 50) {
        ctx.strokeStyle = `rgba(251, 146, 60, ${0.3 + tempRatio * 0.6})`;
        ctx.fillStyle = `rgba(251, 146, 60, ${0.3 + tempRatio * 0.6})`;
        ctx.lineWidth = 5;
        drawUpArrow(ctx, centerX - 40, hy + 25, centerX - 40, hy);
        drawUpArrow(ctx, centerX + 40, hy + 25, centerX + 40, hy);
      }
    }
  }

  // Heat dissipation from heatsink sides
  if (k < 0.1) {
    if (tempRatio > 0.05) {
      const dissOffset = (time * 20) % 40;
      for (let i = 0; i < 3; i++) {
        const dx = 80 + i * 45 + dissOffset;
        if (dx > 80 && dx < 180) {
          ctx.strokeStyle = `rgba(234, 179, 8, ${0.3 + tempRatio * 0.5})`;
          ctx.fillStyle = `rgba(234, 179, 8, ${0.3 + tempRatio * 0.5})`;
          ctx.lineWidth = 4;
          drawLeftArrow(ctx, centerX - dx + 40, hsY + 80, centerX - dx, hsY + 80);
          drawLeftArrow(ctx, centerX - dx + 40, hsY + 110, centerX - dx, hsY + 110);
          drawRightArrow(ctx, centerX + dx - 40, hsY + 80, centerX + dx, hsY + 80);
          drawRightArrow(ctx, centerX + dx - 40, hsY + 110, centerX + dx, hsY + 110);
        }
      }
    }
  } else if (k < 0.2) {
    if (tempRatio > 0.05) {
      const dissOffset = (time * 20) % 40;
      for (let i = 0; i < 3; i++) {
        const dx = 80 + i * 45 + dissOffset;
        if (dx > 80 && dx < 180) {
          ctx.strokeStyle = `rgba(234, 179, 8, ${0.3 + tempRatio * 0.5})`;
          ctx.fillStyle = `rgba(234, 179, 8, ${0.3 + tempRatio * 0.5})`;
          ctx.lineWidth = 4;
          drawRightArrow(ctx, centerX + dx - 40, hsY + 80, centerX + dx, hsY + 80);
          drawRightArrow(ctx, centerX + dx - 40, hsY + 110, centerX + dx, hsY + 110);
        }
      }
    }
  } 

  // ============ CPU CHIP ============
  drawCPU(ctx, centerX, centerY, temp, T0, Tambient, cpuImageRef, isLightMode);

  // Heat generation from CPU
  if (tempRatio > 0.1) {
    const genOffset = (time * 30) % 35;
    ctx.strokeStyle = `rgba(239, 68, 68, ${tempRatio * 0.7})`;
    ctx.lineWidth = 5;

    for (let i = 0; i < 5; i++) {
      const gy = centerY + 170 + i * 40 - genOffset;
      if (gy < centerY + 200) {
        ctx.beginPath();
        ctx.moveTo(centerX - 60, gy);
        ctx.quadraticCurveTo(centerX, gy - 15, centerX + 60, gy);
        ctx.stroke();
      }
    }
  }

  // ============ LABELS ============

  // Fan label - TOP CENTER
  ctx.fillStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.font = 'bold 24px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowBlur = isLightMode ? 0 : 20;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';
  ctx.fillText('FAN (KIPAS)', centerX, fanY - 120);
  ctx.shadowBlur = 0;

  // Cold air label - TOP RIGHT
  ctx.fillStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.font = 'bold 22px sans-serif';
  ctx.textAlign = 'left';
  ctx.shadowBlur = isLightMode ? 0 : 15;
  ctx.shadowColor = isLightMode ? 'transparent' : '#60a5fa';
  ctx.fillText('Udara Dingin', centerX + 200, fanY - 80);
  ctx.fillText('Masuk ‚Üì', centerX + 200, fanY - 50);
  ctx.shadowBlur = 0;

  // Hot air label - TOP LEFT
  ctx.fillStyle = isLightMode ? '#b91c1c' : '#ef4444';
  ctx.font = 'bold 22px sans-serif';
  ctx.textAlign = 'right';
  ctx.shadowBlur = isLightMode ? 0 : 15;
  ctx.shadowColor = isLightMode ? 'transparent' : '#ef4444';
  ctx.fillText('Udara Panas', centerX - 200, fanY - 80);
  ctx.fillText('Keluar ‚Üë', centerX - 200, fanY - 50);
  ctx.shadowBlur = 0;

  let systemName = "Heatsink Pasif";

  if (k <= 0.1) {
    systemName = "Heatsink Pasif";
  } else if (k <= 0.2) {
    systemName = "Fan Cooler";
  } else {
    systemName = "Liquid Cooling";
  }
  
  // Draw system name label 
  ctx.fillStyle = '#60a5fa';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowBlur = 10;
  ctx.shadowColor = '#3b82f6';
  ctx.fillText(systemName, centerX - 130, centerY);
  ctx.shadowBlur = 0;

  if (k <= 0.1) {
    // Heat dissipation labels - FAR LEFT & RIGHT
    if (tempRatio > 0.05) {
      ctx.fillStyle = isLightMode ? '#854d0e' : '#eab308';
      ctx.font = 'bold 20px sans-serif';
      ctx.shadowBlur = isLightMode ? 0 : 15;
      ctx.shadowColor = isLightMode ? 'transparent' : '#eab308';

      ctx.textAlign = 'right';
      ctx.fillText('Penyebaran', centerX - 260, hsY + 85);
      ctx.fillText('Panas ‚Üí', centerX - 260, hsY + 115);

      ctx.textAlign = 'left';
      ctx.fillText('Penyebaran', centerX + 260, hsY + 85);
      ctx.fillText('‚Üê Panas', centerX + 260, hsY + 115);
      ctx.shadowBlur = 0;
    }

  } else if (k <= 0.2) {
    // Heat dissipation labels - FAR LEFT & RIGHT
    if (tempRatio > 0.05) {
      ctx.fillStyle = isLightMode ? '#854d0e' : '#eab308';
      ctx.font = 'bold 20px sans-serif';
      ctx.shadowBlur = isLightMode ? 0 : 15;
      ctx.shadowColor = isLightMode ? 'transparent' : '#eab308';

      ctx.textAlign = 'right';
      ctx.fillText('Konveksi', centerX - 160, hsY + 85);
      ctx.fillText('Paksa ‚Üí', centerX - 160, hsY + 115);

    }

  } else {
    // Heat dissipation labels - FAR LEFT & RIGHT
    if (tempRatio > 0.05) {
      ctx.fillStyle = isLightMode ? '#854d0e' : '#eab308';
      ctx.font = 'bold 20px sans-serif';
      ctx.shadowBlur = isLightMode ? 0 : 15;
      ctx.shadowColor = isLightMode ? 'transparent' : '#eab308';

      ctx.textAlign = 'right';
      ctx.fillText('Sirkulasi', centerX + 220, hsY + 85);
      ctx.fillText('Cairan üîÅ', centerX + 230, hsY + 115);
      drawRightArrow(ctx, centerX + 250, hsY + 90, centerX + 285, hsY + 90);
      ctx.fillText('Transfer', centerX + 390, hsY + 85);
      ctx.fillText('Ke Radiator', centerX + 426, hsY + 115);

    }

  }

  // Conduction label - RIGHT
  if (tempRatio > 0.05) {
    ctx.fillStyle = isLightMode ? '#c2410c' : '#fb923c';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'left';
    ctx.shadowBlur = isLightMode ? 0 : 15;
    ctx.shadowColor = isLightMode ? 'transparent' : '#fb923c';
    ctx.fillText('Konduksi', centerX + 150, centerY + 130);
    ctx.fillText('Panas ‚Üë', centerX + 150, centerY + 160);
    ctx.shadowBlur = 0;
  }

  // CPU heat generation label - BOTTOM CENTER
  if (tempRatio > 0.1) {
    ctx.fillStyle = isLightMode ? '#b91c1c' : '#ef4444';
    ctx.font = 'bold 22px sans-serif';
    ctx.shadowBlur = isLightMode ? 0 : 20;
    ctx.shadowColor = isLightMode ? 'transparent' : '#ef4444';
    ctx.fillText('CPU Menghasilkan', centerX + 100, centerY + 270);
    ctx.fillText('Panas', centerX + 100, centerY + 300);
    ctx.shadowBlur = 0;
  }

  // Temperature display on CPU
  const hue = 120 - tempRatio * 120;
  ctx.fillStyle = `hsl(${hue}, 80%, ${isLightMode ? '40%' : '60%'})`;
  ctx.font = 'bold 38px monospace';
  ctx.textAlign = 'center';
  ctx.shadowBlur = isLightMode ? 0 : 25;
  ctx.shadowColor = isLightMode ? 'transparent' : `hsl(${hue}, 80%, 50%)`;
  ctx.fillText(`${temp.toFixed(1)}¬∞C`, centerX + 170, centerY + 230);
  ctx.shadowBlur = 0;

  // Formula display at bottom
  ctx.fillStyle = isLightMode ? '#1e293b' : '#e2e8f0';
  ctx.font = 'bold 24px monospace';
  ctx.textAlign = 'center';
  ctx.shadowBlur = isLightMode ? 0 : 10;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';
  ctx.fillText('T(t) = T_ambient + (T‚ÇÄ - T_ambient) √ó e^(-kt)', centerX, centerY + 370);
  ctx.shadowBlur = 0;

  // Process flow indicators - FAR RIGHT
  drawProcessFlow(ctx, centerX, centerY, k, T0, Tambient, temp, isLightMode);
};

const drawProcessFlow = (
  ctx: CanvasRenderingContext2D, 
  cx: number, 
  cy: number, 
  k: number, 
  T0: number, 
  Tambient: number, 
  temp: number,
  isLightMode: boolean
) => {
  const tempRatio = (temp - Tambient) / (T0 - Tambient);
  let steps = [];
  
  if (k <= 0.1) {
    // Heatsink Pasif
    steps = [
      { num: '1', label: 'Panas\nDihasilkan', x: cx - 520, y: cy + 330, color: isLightMode ? '#b91c1c' : '#ef4444' },
      { num: '2', label: 'Konduksi\nke Heatsink', x: cx - 520, y: cy + 200, color: isLightMode ? '#c2410c' : '#f97316' },
      { num: '3', label: 'Radiasi dari\nSirip Heatsink', x: cx - 520, y: cy + 60, color: isLightMode ? '#854d0e' : '#eab308' },
      { num: '4', label: 'Konveksi\nAlami', x: cx - 520, y: cy - 80, color: isLightMode ? '#1e40af' : '#3b82f6' },
      { num: '5', label: 'Pendinginan\nLambat', x: cx - 520, y: cy - 220, color: isLightMode ? '#15803d' : '#22c55e' }
    ];
  } else if (k <= 0.2) {
    // Fan Cooler
    steps = [
      { num: '1', label: 'Panas\nDihasilkan', x: cx - 520, y: cy + 330, color: isLightMode ? '#b91c1c' : '#ef4444' },
      { num: '2', label: 'Konduksi\nke Heatsink', x: cx - 520, y: cy + 200, color: isLightMode ? '#c2410c' : '#f97316' },
      { num: '3', label: 'Penyebaran\nPanas', x: cx - 520, y: cy + 60, color: isLightMode ? '#854d0e' : '#eab308' },
      { num: '4', label: 'Konveksi\nPaksa (Fan)', x: cx - 520, y: cy - 80, color: isLightMode ? '#1e40af' : '#3b82f6' },
      { num: '5', label: 'Pendinginan\nModerat', x: cx - 520, y: cy - 220, color: isLightMode ? '#15803d' : '#22c55e' }
    ];
  } else {
    // Liquid Cooling
    steps = [
      { num: '1', label: 'Panas\nDihasilkan', x: cx - 520, y: cy + 330, color: isLightMode ? '#b91c1c' : '#ef4444' },
      { num: '2', label: 'Konduksi ke\nWaterblock', x: cx - 520, y: cy + 200, color: isLightMode ? '#c2410c' : '#f97316' },
      { num: '3', label: 'Sirkulasi\nCairan', x: cx - 520, y: cy + 60, color: isLightMode ? '#854d0e' : '#eab308' },
      { num: '4', label: 'Transfer ke\nRadiator', x: cx - 520, y: cy - 80, color: isLightMode ? '#1e40af' : '#3b82f6' },
      { num: '5', label: 'Pendinginan\nOptimal', x: cx - 520, y: cy - 220, color: isLightMode ? '#15803d' : '#22c55e' }
    ];
  }

  steps.forEach((step, i) => {
    // Circle background
    ctx.fillStyle = step.color + (isLightMode ? '22' : '33');
    ctx.beginPath();
    ctx.arc(step.x, step.y, 35, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = step.color;
    ctx.lineWidth = 3;
    ctx.stroke();

    // Number
    ctx.fillStyle = step.color;
    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(step.num, step.x, step.y + 10);

    // Label
    ctx.fillStyle = isLightMode ? '#1e293b' : '#ffffff';
    ctx.font = 'bold 13px sans-serif';
    const lines = step.label.split('\n');
    lines.forEach((line, li) => {
      ctx.fillText(line, step.x, step.y + 65 + li * 18);
    });

    // Connecting arrow
    if (i < steps.length - 1) {
      ctx.strokeStyle = isLightMode ? '#94a3b8' : '#475569';
      ctx.fillStyle = isLightMode ? '#94a3b8' : '#475569';
      ctx.lineWidth = 2;
      drawUpArrow(ctx, step.x, step.y - 38, step.x, steps[i + 1].y + 38);
    }
  });
};

const drawAmbientAir = (
  ctx: CanvasRenderingContext2D, 
  x: number, 
  y: number, 
  Tambient: number,
  isLightMode: boolean
) => {
  ctx.fillStyle = isLightMode ? 'rgba(96, 165, 250, 0.1)' : 'rgba(96, 165, 250, 0.15)';
  ctx.fillRect(50, y, 1100, 60);

  ctx.strokeStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 5]);
  ctx.strokeRect(50, y, 1100, 60);
  ctx.setLineDash([]);

  ctx.fillStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.font = 'bold 24px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowBlur = isLightMode ? 0 : 10;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';
  ctx.fillText(`UDARA SEKITAR (T_ambient = ${Tambient}¬∞C)`, x, y + 38);
  ctx.shadowBlur = 0;
};

const drawFan = (
  ctx: CanvasRenderingContext2D, 
  x: number, 
  y: number, 
  isRunning: boolean, 
  time: number,
  isLightMode: boolean
) => {
  const radius = 70;

  // Fan glow
  ctx.shadowBlur = isLightMode ? 0 : 30;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';

  // Fan housing
  ctx.strokeStyle = isLightMode ? '#1e3a8a' : '#1e40af';
  ctx.lineWidth = 8;
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.stroke();

  ctx.shadowBlur = 0;

  // Rotating blades
  const rotation = isRunning ? (time * 7) : 0;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(rotation);

  for (let i = 0; i < 4; i++) {
    const bladeGrad = ctx.createRadialGradient(0, 0, 5, 0, 0, 55);
    if (isLightMode) {
      bladeGrad.addColorStop(0, '#93c5fd');
      bladeGrad.addColorStop(0.7, '#3b82f6');
      bladeGrad.addColorStop(1, '#1e3a8a');
    } else {
      bladeGrad.addColorStop(0, '#60a5fa');
      bladeGrad.addColorStop(0.7, '#3b82f6');
      bladeGrad.addColorStop(1, '#1e3a8a');
    }

    ctx.fillStyle = bladeGrad;
    ctx.beginPath();
    ctx.ellipse(32, 0, 35, 14, 0, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = isLightMode ? '#1e3a8a' : '#1e40af';
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.rotate(Math.PI / 2);
  }
  ctx.restore();

  // Center hub with 3D effect
  const hubGrad = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, 18);
  if (isLightMode) {
    hubGrad.addColorStop(0, '#dbeafe');
    hubGrad.addColorStop(0.5, '#93c5fd');
    hubGrad.addColorStop(1, '#1e40af');
  } else {
    hubGrad.addColorStop(0, '#dbeafe');
    hubGrad.addColorStop(0.5, '#60a5fa');
    hubGrad.addColorStop(1, '#1e40af');
  }

  ctx.fillStyle = hubGrad;
  ctx.beginPath();
  ctx.arc(x, y, 18, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = isLightMode ? '#1e3a8a' : '#1e3a8a';
  ctx.lineWidth = 2;
  ctx.stroke();
};

const drawHeatsink = (
  ctx: CanvasRenderingContext2D, 
  x: number, 
  y: number, 
  k: number,
  heatsinkImageRef: RefObject<HTMLImageElement | null>,
  fancoolerImageRef: RefObject<HTMLImageElement | null>,
  liquidImageRef: RefObject<HTMLImageElement | null>,
  isLightMode: boolean
) => {
  const width = 240;
  const height = 240;

  // Determine cooling system based on k value
  let coolingImage = heatsinkImageRef.current;

  if (k <= 0.1) {
    coolingImage = heatsinkImageRef.current;
  } else if (k <= 0.2) {
    coolingImage = fancoolerImageRef.current;
  } else {
    coolingImage = liquidImageRef.current;
  }

  if (coolingImage) {
    ctx.save();
    ctx.shadowBlur = isLightMode ? 0 : 20;
    ctx.shadowColor = isLightMode ? 'transparent' : 'rgba(100, 150, 200, 0.5)';
    ctx.drawImage(coolingImage, x - width / 2, y - 20, width, height);
    ctx.restore();
  }
};

const drawCPU = (
  ctx: CanvasRenderingContext2D, 
  x: number, 
  y: number, 
  temp: number,
  T0: number,
  Tambient: number,
  cpuImageRef: RefObject<HTMLImageElement | null>,
  isLightMode: boolean
) => {
  const cpuYOffset = 160;
  const cy = y + cpuYOffset;
  const size = 120;
  const tempRatio = (temp - Tambient) / (T0 - Tambient);

  if (cpuImageRef.current && cpuImageRef.current.complete) {
    ctx.save();

    // Efek glow berdasarkan suhu (lebih halus)
    const hue = 120 - tempRatio * 120;
    ctx.shadowBlur = 30 + tempRatio * 20;
    ctx.shadowColor = `hsla(${hue}, 80%, 50%, ${0.6 + tempRatio * 0.4})`;

    // Draw CPU image
    ctx.drawImage(cpuImageRef.current, x - size / 2, cy - size / 2 + 100, size, size);

    ctx.shadowBlur = 0;
    ctx.restore();
  } else {
    // Fallback to original drawing if image not loaded
    const hue = 120 - tempRatio * 120;
    const cpuGrad = ctx.createLinearGradient(x - size / 2, cy - size / 2, x + size / 2, cy + size / 2);
    if (isLightMode) {
      cpuGrad.addColorStop(0, `hsl(${hue}, 75%, 70%)`);
      cpuGrad.addColorStop(0.5, `hsl(${hue}, 75%, 60%)`);
      cpuGrad.addColorStop(1, `hsl(${hue}, 75%, 45%)`);
    } else {
      cpuGrad.addColorStop(0, `hsl(${hue}, 75%, 60%)`);
      cpuGrad.addColorStop(0.5, `hsl(${hue}, 75%, 50%)`);
      cpuGrad.addColorStop(1, `hsl(${hue}, 75%, 35%)`);
    }

    ctx.shadowBlur = isLightMode ? 0 : 25;
    ctx.shadowColor = isLightMode ? 'transparent' : `hsl(${hue}, 75%, 45%)`;
    ctx.fillStyle = cpuGrad;
    ctx.fillRect(x - size / 2, cy - size / 2, size, size);
    ctx.shadowBlur = 0;

    // Grid pattern
    ctx.strokeStyle = isLightMode ? `hsl(${hue}, 60%, 45%)` : `hsl(${hue}, 60%, 25%)`;
    ctx.lineWidth = 2;
    for (let i = 1; i < 5; i++) {
      ctx.beginPath();
      ctx.moveTo(x - size / 2 + (size / 5) * i, cy - size / 2);
      ctx.lineTo(x - size / 2 + (size / 5) * i, cy + size / 2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x - size / 2, cy - size / 2 + (size / 5) * i);
      ctx.lineTo(x + size / 2, cy - size / 2 + (size / 5) * i);
      ctx.stroke();
    }

    // CPU border with 3D effect
    ctx.strokeStyle = isLightMode ? `hsl(${hue}, 60%, 40%)` : `hsl(${hue}, 60%, 20%)`;
    ctx.lineWidth = 5;
    ctx.strokeRect(x - size / 2, cy - size / 2, size, size);

    // Highlight edge
    ctx.strokeStyle = isLightMode ? `hsl(${hue}, 60%, 80%)` : `hsl(${hue}, 60%, 70%)`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x - size / 2, cy - size / 2);
    ctx.lineTo(x + size / 2, cy - size / 2);
    ctx.lineTo(x + size / 2, cy + size / 2);
    ctx.stroke();
  }
};

const drawTemperatureGraph = (
  params: Omit<DrawingParams, 'imagesLoaded' | 'isRunning' | 'cpuImageRef' | 'heatsinkImageRef' | 'fancoolerImageRef' | 'liquidImageRef'>
) => {
  const { ctx, width, height, temp, time, params: simParams, isLightMode } = params;
  const { T0, Tambient, k } = simParams;
  
  const graphX = 100;
  const graphY = height - 280;
  const graphWidth = width - 200;
  const graphHeight = 200;

  // Graph background with gradient
  if (isLightMode) {
    ctx.fillStyle = '#e0f2fe';
    ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
  } else {
    const graphBg = ctx.createLinearGradient(graphX, graphY, graphX, graphY + graphHeight);
    graphBg.addColorStop(0, '#1e293b');
    graphBg.addColorStop(1, '#0f172a');
    ctx.fillStyle = graphBg;
    ctx.fillRect(graphX, graphY, graphWidth, graphHeight);
  }

  // Border
  ctx.strokeStyle = isLightMode ? '#94a3b8' : '#475569';
  ctx.lineWidth = 3;
  ctx.strokeRect(graphX, graphY, graphWidth, graphHeight);

  // Grid
  ctx.strokeStyle = isLightMode ? '#cbd5e1' : '#334155';
  ctx.lineWidth = 1;
  for (let i = 1; i <= 4; i++) {
    // Horizontal
    const gy = graphY + (graphHeight / 5) * i;
    ctx.beginPath();
    ctx.moveTo(graphX, gy);
    ctx.lineTo(graphX + graphWidth, gy);
    ctx.stroke();

    // Vertical
    const gx = graphX + (graphWidth / 5) * i;
    ctx.beginPath();
    ctx.moveTo(gx, graphY);
    ctx.lineTo(gx, graphY + graphHeight);
    ctx.stroke();
  }

  // Y-axis labels
  ctx.fillStyle = isLightMode ? '#1e293b' : '#cbd5e1';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'right';
  for (let i = 0; i <= 4; i++) {
    const tempVal = T0 - (T0 - Tambient) * (i / 4);
    const gy = graphY + (graphHeight / 4) * i;
    ctx.fillText(`${tempVal.toFixed(0)}¬∞C`, graphX - 15, gy + 5);
  }

  // X-axis labels
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    const timeVal = (time / 5) * i;
    const gx = graphX + (graphWidth / 5) * i;
    ctx.fillText(`${timeVal.toFixed(1)}s`, gx, graphY + graphHeight + 25);
  }

  // Plot temperature curve
  ctx.strokeStyle = isLightMode ? '#15803d' : '#22c55e';
  ctx.lineWidth = 4;
  ctx.shadowBlur = isLightMode ? 0 : 15;
  ctx.shadowColor = isLightMode ? 'transparent' : '#22c55e';
  ctx.beginPath();

  let firstPoint = true;
  for (let i = 0; i <= time * 20; i++) {
    const t = i / 20;
    const tempVal = calculateTemp(t, simParams);
    const gx = graphX + (t / (time > 0 ? time : 1)) * graphWidth;
    const gy = graphY + graphHeight - ((tempVal - Tambient) / (T0 - Tambient)) * graphHeight;

    if (firstPoint) {
      ctx.moveTo(gx, gy);
      firstPoint = false;
    } else {
      ctx.lineTo(gx, gy);
    }
  }
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Current point indicator
  if (time > 0) {
    const currentX = graphX + graphWidth;
    const currentY = graphY + graphHeight - ((temp - Tambient) / (T0 - Tambient)) * graphHeight;

    ctx.fillStyle = isLightMode ? '#15803d' : '#22c55e';
    ctx.shadowBlur = isLightMode ? 0 : 20;
    ctx.shadowColor = isLightMode ? 'transparent' : '#22c55e';
    ctx.beginPath();
    ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Title
  ctx.fillStyle = isLightMode ? '#1e293b' : '#ffffff';
  ctx.font = 'bold 22px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowBlur = isLightMode ? 0 : 10;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';
  ctx.fillText('GRAFIK PENDINGINAN CPU', graphX + graphWidth / 2, graphY - 20);
  ctx.shadowBlur = 0;
};

const drawAirflowArrow = (
  ctx: CanvasRenderingContext2D, 
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number,
  isLightMode: boolean
) => {
  ctx.strokeStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.fillStyle = isLightMode ? '#1e40af' : '#60a5fa';
  ctx.lineWidth = 4;
  ctx.shadowBlur = isLightMode ? 0 : 10;
  ctx.shadowColor = isLightMode ? 'transparent' : '#3b82f6';

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrow head untuk panah ke BAWAH (di ujung y2)
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - 8, y2 - 12);
  ctx.lineTo(x2 + 8, y2 - 12);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
};

const drawHotAirArrow = (
  ctx: CanvasRenderingContext2D, 
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number,
  isLightMode: boolean
) => {
  ctx.strokeStyle = isLightMode ? '#b91c1c' : '#ef4444';
  ctx.fillStyle = isLightMode ? '#b91c1c' : '#ef4444';
  ctx.lineWidth = 4;
  ctx.shadowBlur = isLightMode ? 0 : 10;
  ctx.shadowColor = isLightMode ? 'transparent' : '#dc2626';

  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrow head untuk panah ke ATAS (di ujung y2)
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - 8, y2 + 12);
  ctx.lineTo(x2 + 8, y2 + 12);
  ctx.closePath();
  ctx.fill();
  ctx.shadowBlur = 0;
};

const drawUpArrow = (
  ctx: CanvasRenderingContext2D, 
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number
) => {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrow head di ujung atas (y2)
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - 7, y2 + 12);
  ctx.lineTo(x2 + 7, y2 + 12);
  ctx.closePath();
  ctx.fill();
};

const drawLeftArrow = (
  ctx: CanvasRenderingContext2D, 
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number
) => {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrow head di ujung kiri (x2)
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 + 12, y2 - 7);
  ctx.lineTo(x2 + 12, y2 + 7);
  ctx.closePath();
  ctx.fill();
};

const drawRightArrow = (
  ctx: CanvasRenderingContext2D, 
  x1: number, 
  y1: number, 
  x2: number, 
  y2: number
) => {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();

  // Arrow head di ujung kanan (x2)
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - 12, y2 - 7);
  ctx.lineTo(x2 - 12, y2 + 7);
  ctx.closePath();
  ctx.fill();
};


